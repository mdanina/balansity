-- ============================================
-- Supabase Migration: Initial Schema
-- ============================================
-- Создание базовых таблиц для Little Otter / Balansity
-- PostgreSQL + JSONB для гибкости

-- ============================================
-- 1. Таблица users (Родительский аккаунт)
-- ============================================
-- Расширение auth.users из Supabase Auth
create table if not exists public.users (
  id uuid references auth.users(id) on delete cascade not null primary key,
  email text,
  phone text,
  region text, -- "Москва", "Санкт-Петербург" (для фильтрации услуг)
  marketing_consent boolean default false, -- Согласие на рассылку
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- Индексы для users
create index if not exists idx_users_email on public.users(email);
create index if not exists idx_users_region on public.users(region);

-- ============================================
-- 2. Таблица profiles (Члены семьи)
-- ============================================
create table if not exists public.profiles (
  id uuid default gen_random_uuid() primary key,
  user_id uuid references public.users(id) on delete cascade not null,
  
  type text not null check (type in ('parent', 'child', 'partner', 'sibling', 'caregiver', 'other')),
  first_name text not null,
  last_name text,
  
  -- Для детей (важно для норм SDQ):
  dob date, -- Date of birth
  gender text check (gender in ('male', 'female', 'other')),
  pronouns text, -- 'he', 'she', 'they', 'other'
  
  -- "Worry Domains" (теги проблем, выбранные при создании):
  worry_tags text[], -- Массив строк: ['anxiety', 'sleep', 'tantrums']
  
  -- Дополнительная информация
  referral text, -- Откуда направлен
  seeking_care text check (seeking_care in ('yes', 'no')),
  
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- Индексы для profiles
create index if not exists idx_profiles_user_id on public.profiles(user_id);
create index if not exists idx_profiles_type on public.profiles(type);
create index if not exists idx_profiles_dob on public.profiles(dob);

-- ============================================
-- 3. Таблица assessments (Сессии диагностики)
-- ============================================
create table if not exists public.assessments (
  id uuid default gen_random_uuid() primary key,
  profile_id uuid references public.profiles(id) on delete cascade not null,
  
  -- Тип опросника
  assessment_type text not null check (assessment_type in ('checkup', 'parent', 'family')),
  
  -- Статус прохождения (чтобы можно было допройти позже):
  status text check (status in ('in_progress', 'completed', 'abandoned')) default 'in_progress',
  current_step int default 1, -- На каком вопросе остановился (для progress bar)
  total_steps int, -- Общее количество вопросов
  
  -- МОНЕТИЗАЦИЯ (Paywall):
  is_paid boolean default false, -- Оплачен ли полный отчет?
  payment_id text, -- ID платежа в ЮКасса/другой системе
  
  -- Кэшированные результаты (чтобы не пересчитывать каждый раз):
  -- Сюда запишем JSON вида: { "emotional": "concerning", "hyperactivity": "typical" }
  results_summary jsonb,
  
  -- Метаданные
  started_at timestamptz default now(),
  completed_at timestamptz,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- Индексы для assessments
create index if not exists idx_assessments_profile_id on public.assessments(profile_id);
create index if not exists idx_assessments_status on public.assessments(status);
create index if not exists idx_assessments_type on public.assessments(assessment_type);
create index if not exists idx_assessments_is_paid on public.assessments(is_paid);

-- ============================================
-- 4. Таблица answers (Сырые ответы)
-- ============================================
create table if not exists public.answers (
  id bigint generated by default as identity primary key,
  assessment_id uuid references public.assessments(id) on delete cascade not null,
  
  question_code text not null, -- ID вопроса: 'checkup_01', 'checkup_22', 'parent_01', 'family_01'
  question_id int not null, -- Числовой ID вопроса из исходных данных
  category text, -- 'О ребенке', 'О влиянии', 'О вас', 'О семье'
  
  value int not null, -- Ответ: 0, 1, 2, 3, 4
  answer_type text, -- 'default', 'impact', 'frequency', 'wellbeing', 'relationship', 'sex'
  
  step_number int, -- Порядковый номер вопроса в сессии (для восстановления прогресса)
  
  created_at timestamptz default now(),
  updated_at timestamptz default now(),
  
  -- Уникальность: один ответ на один вопрос в одной сессии
  unique(assessment_id, question_id)
);

-- Индексы для answers
create index if not exists idx_answers_assessment_id on public.answers(assessment_id);
create index if not exists idx_answers_question_code on public.answers(question_code);
create index if not exists idx_answers_category on public.answers(category);

-- ============================================
-- 5. Триггеры для updated_at
-- ============================================
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Применяем триггеры
create trigger update_users_updated_at before update on public.users
  for each row execute function update_updated_at_column();

create trigger update_profiles_updated_at before update on public.profiles
  for each row execute function update_updated_at_column();

create trigger update_assessments_updated_at before update on public.assessments
  for each row execute function update_updated_at_column();

create trigger update_answers_updated_at before update on public.answers
  for each row execute function update_updated_at_column();

-- ============================================
-- 6. Функция для автоматического создания профиля пользователя
-- ============================================
create or replace function public.handle_new_user()
returns trigger as $$
begin
  insert into public.users (id, email)
  values (new.id, new.email);
  return new;
end;
$$ language plpgsql security definer;

-- Триггер для автоматического создания записи в public.users
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute function public.handle_new_user();












